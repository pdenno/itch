
* ToDo
** DONE Draw a BlockShape (probably CmdShape) with quil. 
   CLOSED: [2017-12-04 Mon 07:53]
** TODO Move blocks.
** TODO Make text/number fields editable. (Make number fields.)
** TODO Create stacks.
** TODO Create C and E style blocks, other blocks.
** TODO Create scripts tab
* Notes, general
** Use of quil on scripts-tab/script-window:
 It might be necessary for scripts-tab/scripts window to be one integrated quil thing.
 Otherwise, I don't see how we can smoothly drag a Block from the Scripts-tab to the scripts-window.

* Notes on Scratch
** Blocks
  [[file:~/Documents/git/scratch-flash/src/blocks/][Blocks]] (directory) -- right click to open in emacs. 

*** BlockShape.as
// [[file:~/Documents/git/scratch-flash/src/blocks/BlockShape.as::*%20Scratch%20Project%20Editor%20and%20Player][BlockShape]] handles drawing and resizing of a block shape.
This seems to be the one to start with. Goal: draw some of these with quill.
**** Some shapes
***** Simple RectShape, BooleanShape, NumberShape, CmdShape, FinalCmdShape, HatShape, ProcHatShape
***** C-shaped: LoopShape, FinalLoopShape
***** E-shaped: IfElseShape
	// Geometry
	public static const NotchDepth:int = 3;
	public static const EmptySubstackH:int = 12;
	public static const SubstackInset:int = 15;

*** Block.as
// A Block is a graphical object representing a program statement (command)
// or function (reporter). A stack is a sequence of command blocks, where
// the following command and any nested commands (e.g. within a loop) are
// children. Blocks come in a variety of shapes and usually have some
// combination of label strings and arguments (also children).
//
// The Block class manages block shape, labels, arguments, layout, and
// block sequence. It also supports generation of the labels and argument
// sequence from a specification string (e.g. "%n + %n") and type (e.g. reporter).


*** BlockArg.as
// A BlockArg represents a Block argument slot. Some BlockArgs, contain
// a text field that can be edited by the user. Others (e.g. booleans)
// are immutable. In either case, they be replaced by a reporter block
// of the right type. That is, dropping a reporter block onto a BlockArg
// inside a block causes the BlockArg to be replaced by the reporter.
// If a reporter is removed, a BlockArg is added to the block.
//
// To create a custom BlockArg widget such as a color picker, make a
// subclass of BlockArg for the widget. Your constructor is responsible
// for adding child display objects and setting its width and height.
// The widget must initialize argValue and update it as the user
// interacts with the widget. In some cases, the widget may need to
// override the setArgValue() method. If the widget can accept dropped
// arguments, it should set base to a BlockShape to support drag feedback.




* Log
** <2017-12-01 Fri>
*** Started!
** <2017-12-02 Sat>
*** Basic stuff for scripts tab/blocks
 I'm guessing that the most basic useful block has 'CmdShape' (the Scratch term). 
** <2017-12-03 Sun>
*** I probably won't need this:
(defn widget-interleave
  [features]
  "Create a vector of text/widget features i
  (let [text    (:text features)
        widgets (:widgets features)
        inter (vec (interleave text widget))]
    (if (== (count text) (coutn widget))
      inter
      (conj inter (last text)))))

*** I wrote/arranged the basic block widgets (text and text fields in widgets). 
